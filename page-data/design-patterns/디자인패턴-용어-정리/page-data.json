{"componentChunkName":"component---src-templates-blog-post-js","path":"/design-patterns/디자인패턴-용어-정리/","result":{"data":{"site":{"siteMetadata":{"title":"10cheon00의 Archive"}},"markdownRemark":{"id":"d7ac611c-8105-568c-8e48-ab690be566a6","excerpt":"…","html":"<h1 id=\"객체\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4\" aria-label=\"객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"16\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>객체</h1>\n<p>데이터 + 프로시저(데이터를 다루는 연산, 작업)를 함께 묶은 단위다.</p>\n<p>객체는 요청을 통해 내부에 있는 데이터 또는 상태를 변경한다.</p>\n<p>요청은 <strong>객체의 상태를 변경하는 유일한 방법</strong>이다. 오직 요청을 통해서만 가능하도록 제약 사항을 거는데, 이걸 캡슐화라고 한다. 캡슐화를 통해 객체의 내부 동작을 숨겨 외부에서 알 수 없도록 한다.</p>\n<p>실세계를 토대로 객체를 구성하다보면 현재의 모습만 반영한 모델이 될 뿐 미래의 요청 사항을 반영할 수 없는 모델이 된다. 디자인 패턴을 통해 유연한 설계를 거쳐 미래의 실세계를 잘 반영할 수 있도록 한다.</p>\n<h1 id=\"인터페이스\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"16\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>인터페이스</h1>\n<p>객체가 요청을 받아 처리할 수 있는 모든 연산들의 집합이다.</p>\n<p>특정 인터페이스를 지칭하기 위해 타입을 이용해 나타낸다.</p>\n<p>객체는 여러 인터페이스를 가질 수 있고, 인터페이스가 다른 인터페이스를 가질 수도 있다.</p>\n<p>이 때 다른 인터페이스를 가지는 인터페이스를 서브타입이라고 하고 다른 인터페이스에 포함되는 인터페이스를 슈퍼타입이라고 한다. 간단하게 나타내기 위해 인터페이스를 상속한다고 표현한다.</p>\n<p>객체는 <strong>오직 이 인터페이스를 통해 자신을 드러낸다</strong>. 그러나 내부 구현은 객체에 정의된 내용에 따라 달라진다. 동일한 요청이라도 객체마다 다른 방식으로 동작한다.</p>\n<p>요청에 따라 실행될 연산을 <em>런타임 시점</em>에 결정짓게 되는데, 이것을 동적바인딩이라고 한다. 동일한 요청이지만 처리할 객체에 따라 다른 동작을 보여준다는 점은 객체지향의 특징인 다형성이 드러난다고 할 수 있다.</p>\n<h1 id=\"인터페이스에-따르는-프로그래밍\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%97%90-%EB%94%B0%EB%A5%B4%EB%8A%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"인터페이스에 따르는 프로그래밍 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"16\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>인터페이스에 따르는 프로그래밍</h1>\n<p>추상 클래스를 정의하고 인터페이스로 사용하여 상속받을 경우 두 가지 이점이 있다.</p>\n<ul>\n<li>객체가 인터페이스를 지원하는 한 객체의 구체적인 타입을 알 필요는 없다.</li>\n<li>객체를 구현하는 클래스가 어떤 것인지 알 필요는 없고 <strong>인터페이스를 정의한 추상 클래스</strong>만 알면 된다.</li>\n</ul>\n<p>이 내용은 의존성 역전 원칙과 비슷한 내용같다. 추상화에 의존하여 구현해야한다.</p>\n<h1 id=\"상속과-합성\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D%EA%B3%BC-%ED%95%A9%EC%84%B1\" aria-label=\"상속과 합성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"16\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>상속과 합성</h1>\n<p>상속은 부모 클래스의 구현을 그대로 받아와 하위 클래스의 구현을 정의하는 것이다.</p>\n<p><em>컴파일 시점</em>에 정적으로 정의되고 하위 클래스에서 부모 클래스에 정의된 구현을 재정의할 수 있다.</p>\n<p>하지만 부모 클래스에 정의된 구현을 <strong>런타임 시기에 변경할 수 없고</strong>, 부모 클래스의 요구사항이 달라졌다거나 정의된 구현이 변경될 경우 종속된 하위 클래스에게도 영향이 가기 마련이다.</p>\n<p>합성은 <strong>객체가 다른 객체에 대한 참조자를 얻는 방식</strong>이다. 객체 내에 구현된 프로시저보다 인터페이스에 정의된 내용만 바라보게 된다. 동일한 인터페이스라면 <em>런타임 시점</em>에 다른 객체로 대체될 수 있고, 인터페이스에 맞춰 객체를 구현하기 때문에 종속성도 줄어들게 된다.</p>\n<p>일반적으로 상속보다 합성을 좋은 방법이라고 한다.</p>\n<h1 id=\"위임\" style=\"position:relative;\"><a href=\"#%EC%9C%84%EC%9E%84\" aria-label=\"위임 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"16\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>위임</h1>\n<p>수신 객체와 위임자가 한 요청을 처리하는 것이다. 수신 객체가 요청을 수신하고, 위임자에게 이 요청을 처리해달라고 한다.</p>\n<p>위임자는 런타임에 변경될 수 있으므로 요청을 처리하는 방법도 달라질 수 있다. 이를 위해서는 수신 객체가 위임자를 인스턴스로(<strong>Has-A</strong>관계로) 갖고 있어야 한다.</p>","frontmatter":{"title":"디자인 패턴 용어 정리","date":"July 13, 2023","description":"GoF의 디자인 패턴이라는 책을 공부한 후 관련된 용어를 정리한 글입니다.","tags":["design-pattern"]}},"previous":{"fields":{"slug":"/algorithms/백준-19532/"},"frontmatter":{"title":"백준 19532"}},"next":{"fields":{"slug":"/design-patterns/추상-팩토리-패턴/"},"frontmatter":{"title":"추상 팩토리 패턴"}}},"pageContext":{"id":"d7ac611c-8105-568c-8e48-ab690be566a6","previousPostId":"0290f924-9a47-586b-b154-958b2ccab846","nextPostId":"44b3b462-98bb-502c-971b-041ff8a995b9"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}