---
title: 보안
date: '2023-12-15T13:40:32.000Z'
tags: ["computer-network"]
---

> 2023년 2학기 컴퓨터 네트워크 수업을 듣고 정리한 내용입니다.

# 용어

- Confidentiality = 기밀성

  송,수신자 외에 다른 사람이 메세지를 들여다 볼 수 없음을 의미한다.

- Authentication = 인증

  송,수신자가 서로의 존재를 알아볼 수 있음을 의미한다.

- Integrity = 무결성

  메세지가 전송과정에서 오염되지 않았음을 의미한다.

# 암호화란

어떤 메세지를 다른 사람에게 들키지 않으려면 송,수신자끼리 정한 규칙에 따라 암호로 나타낸다. 이 암호는 두 사람만 이해가능하다. 암호로 나타내려면 어떤 규칙이 필요한데 이걸 key라고 부른다.

송신자는 key를 통해 메세지 즉, 평문을 암호화하여 암호문으로 만든다. 수신자는 암호문을 다시 평문으로 바꿔 이해하여야 하기 때문에 복호화를 할 수 있는 key를 갖는다. 

$$
m = 평문\\ 
K_a = 암호화 키\\
K_b = 복호화 키
$$
$$
m = K_b(K_a(m))
$$

## 대칭키

또 다른 이론으로는 송신자와 수신자가 같은 키를 갖고 암호화를 진행하는 것이다. 단순히 데이터를 다른 데이터로 치환하는 구조라서 단순함과 빠른 연산 속도를 갖는다. 

$$
m = 평문\\ 
K_s = 대칭키
$$
$$
m = K_s(K_s(m))
$$

대신 키가 단순할 수록 해킹이 쉬워지므로 무식하게 키의 길이를 늘려서 사용한다.

## 공개키, 비밀키

보안을 위해 대칭키를 사용하려면 송신자와 수신자 모두 같은 키를 갖고 있어야 한다. 하지만 송신자와 수신자가 서로 만난 적이 없어 키를 갖지 않은 경우에서는 대칭키 암호화 방식을 사용할 수 없다. 보안이 없는 환경에서 보안을 위해 대칭키를 전달한다면 키가 노출되기 때문에 안전하게 전달할 수 없다.

그렇기 때문에 모두에게 공개된 공개키(public key)와 자기 자신만 갖는 비밀키(private key)를 구분하는 구조로 바뀌었다.

$$
m = 평문\\ 
K_a^+ = 공개 키\\
K_a^- = 개인 키
$$
$$
m = K_a^-(K_a^+(m)) = K_a^+(K_a^-(m))
$$

공개키 암호화 방식은 모듈러 연산을 이용한다. 

큰 소수 두 개 p, q를 생성하고, $$n = pq$$의 n과 $$z = (p-1)*(q-1)$$의 z를 계산한다.

z보다 작고 서로소인 어떤 수 e를 구한 후 $${ed-1}\mod z = 0$$인 d를 구한다.

이제 $(n, e)$는 공개키, $(n, d)$는 비밀키가 된다.

모듈러 연산에 의해 $m^{ed}\mod n$은 항상 m이 되기 때문에 공개키로 암호화된 메세지를 비밀키로 해독해낼 수 있다. 그렇기 때문에 큰 수를 모듈러 연산하기 위해 걸리는 시간이 크다는 단점이 있다.

### 세션키 공유

공개키 암호화 방식은 대칭키에 비해 키를 알아내기 거의 불가능하므로 **대칭키를 전달하기 위해 공개키 암호화 방식을 사용한다.**

# 인증

두 네트워크 호스트 간 인증을 하려고 이것저것 전달하려하니 중간에 패킷이 탈취당할 수 있다. 그래서 아무 의미없는 난수를 통해 인증을 진행한다.

서버가 생성한 난수를 클라이언트에게 전송하면 클라이언트가 자신의 비밀키로 암호화하여 전송한다. 그리고 서버는 클라이언트의 공개키를 이용하여 클라이언트가 전송한 암호문을 복호화하여 서버가 보낸 난수인지 확인한다. 

그러나 이 방법 또한 공격자가 서버와 클라이언트 사이에서 패킷을 가로채 둘 사이를 중계해버릴 수 있는 문제가 있다.

# 무결성

## 디지털 서명

문서의 주인이 송신자임을 나타내는 서명이다. 송신자는 문서를 비밀키로 암호화하여 문서와 같이 전송한다. 수신자는 이 문서의 서명을 송신자의 공개키로 해독하여 송신자가 서명했음을 확인함으로 위조되지 않았음을 알게 된다.

## Digests

비밀키로 문서를 암호화하려고 하다보니, 문서의 길이가 너무 길다면 암호화 및 복호화에 시간이 많이 걸린다. 따라서 문서를 정해진 해시 함수에 넣어 크기를 줄인 후 서명하는 방법을 사용한다.

1. 송신자는 메세지($$m$$)와, 해시 함수를 거친 메세지($$H(m)$$)를 비밀키로 암호화하여 같이 전송한다.
2. 수신자는 송신자와 같은 해시 함수($$H(m)$$)를 사용해 메세지($$m$$)를 변환한다.
3. 수신자는 송신자의 공개키를 이용해 송신자의 비밀키로 암호화된 $$H(m)$$을 복호화해낸다.
4. 2번에서 만든 값과 3번에서 만든 값을 비교해 무결성을 검증한다.

[인증](#인증) 항목에서, 공격자가 서버와 클라이언트 사이에서 상대방인척 위장할 수 있는 문제가 있었다. [무결성](#무결성)에서 이 문제를 해결하기 위해 서명을 거치는 방법을 사용했지만 여전히 중간에서 공격자가 상대방인 척 위장할 수 있다.

![Alt text](image.png)

이 방법을 보완하려면 공개키를 누군가 보증하면 해결된다. 기관에 공개키를 등록해 두고, 인증을 할 때마다 그 기관이 서명한 공개키를 사용하면 된다. 

# 이메일 보안

무결성, 기밀성을 지키면서 이메일을 전송하려고 한다. 앞서 공개키 암호화 방식을 사용하여 대칭키를 전송한 방법, 문서를 해시 함수에 넣은 후 공개키 암호화 방식을 사용해 전송한 방법을 사용한다.

## 송신자

![Alt text](image-1.png)

1. 송신자는 문서($$m$$)를 해시 함수로 크기를 고정시킨 후 그 값을 비밀키로 암호화한다. 

$$
K_A^-(H(m))
$$

2. 문서($$m$$)와 비밀키로 암호화한 값을 함께 대칭키로 암호화한다.

$$
K_s(K_A^-(H(m)), m)
$$

3. 수신자의 공개키를 이용해 대칭키를 암호화한다.

$$
K_b^+(K_s)
$$

4. 2, 3번의 결과를 같이 전송한다.

## 수신자

![Alt text](image-2.png)

5. 수신자는 자신의 비밀키$$K_B^-$$로 대칭키를 얻어낸다.
$$
K_B^-(K_B^+(K_s)) = K_s
$$
6. 대칭키를 이용해 문서를 복호화하고, 송신자의 비밀키로 암호화된 데이터를 송신자의 공개키$$K_A^+$$로 복호화한다.
$$
K_s(K_s(K_A^-(H(m)))) = K_A^-(H(m))
$$
$$
K_A^+(K_A^-(H(m))) = H(m)
$$
7. 해시 함수에 문서를 넣어 얻은 값와 6번에서 얻은 값을 비교하여 무결성을 검증한다.

이 때 해시 함수는 송신자가 사용한 함수와 같아야 한다.

# Transport-Layer Security

TLS 프로토콜은 두 호스트 사이에 보안 환경을 제공하는 프로토콜이다. 전송 계층, 세션 계층 사이에서 동작한다.

## Handshake

TCP Handshake를 진행하고 나서 TLS Handshake를 진행한다. 이 과정에서는 TLS 버전, 암호화 알고리즘을 선택하고 서로의 인증서를 교환하여 통신하려는 상대가 유효한지 검증한다. 

1. 클라이언트는 서버에게 `Client Hello` 메세지를 전송한다.

    여기에는 클라이언트가 지원하는 **암호화 알고리즘(Cipher suite) 리스트**, **클라이언트가 임의로 생성한 난수**, 그리고 세션 ID를 함께 전송한다.

2. 서버는 이에 응답하여 `Server Hello` 메세지를 전송한다.

    클라이언트가 제공한 암호화 알고리즘중에서 하나를 선택하여 클라이언트에게 알린다. 그리고 세션 ID, 서버의 인증서 그리고 **서버가 생성한 임의의 난수**도 함께 전송한다. 

3. 클라이언트는 서버의 인증서를 검증하고, 인증서가 신뢰할만하다면 앞서 전송한 난수와 서버가 전송한 난수를 조합하여 `pre-master secret`을 생성한 후 인증서를 통해 얻은 서버의 공개키로 암호화하여 전송한다. 그리고 클라이언트 또한 인증서를 전송한다.

4. 서버는 클라이언트의 인증서를 검증하고, 인증서가 신뢰할만하다면 비밀키로 `pre-master secret`을 해독한 후 **`pre-master secret`**과, **서버의 난수**, **클라이언트의 난수**를 조합하여 세션키를 생성한다. 클라이언트 또한 이 값들을 갖고 있기 때문에 양 쪽 모두 세션키를 얻게 된다. 

이 과정을 매 TLS Connection마다 진행하면 시간이 꽤 걸리기 때문에 세션 ID를 부여하여서 같은 세션 ID를 사용하여 요청할 경우 Handshake 과정을 생략한다. 

## Key Derivation

생성된 세션키로 암호화, 복호화를 한 후 무결성을 검증할 때 쓸 수 있지만 키 하나로 모든 걸 다해버리면 좋지 않다. 따라서 세션키와 다른 난수를 통해 네 가지의 키를 생성한다.

- $$E_c$$ : 클라이언트가 서버에게 데이터를 전송할 때 사용할 세션키 
- $$M_c$$ : 클라이언트가 무결성을 위해 사용할 MAC키
- $$E_s$$ : 서버가 클라이언트에게 데이터를 전송할 때 사용할 세션키
- $$M_s$$ : 서버가 무결성을 위해 사용할 MAC키

서버와 클라이언트가 같은 세션키와 난수값을 보유하고 있기 때문에 서버와 클라이언트 모두 위 4가지의 같은 키를 보유하게 된다.

## Data Transfer

위에서 생성한 4가지의 키를 통해 데이터를 암호화하고 무결성을 보증하여 전송한다. 서로 갖고 있는 세션키를 통해 암호화, 복호화를 진행하면 된다.

무결성을 보증하기 위해서는 데이터와 MAC을 같이 전송하고, 수신측에서는 받은 데이터을 변환했을 때  MAC과 같아야 한다. 그러나 데이터의 크기가 매우 크면 fragmentation으로 데이터를 쪼개어 전송하게 된다. 쪼갠 데이터의 마지막 fragment에 MAC이 전송되면 **모든 fragment를 수신해야만 무결성 검증이 가능하다**. 그러므로 무작정 기다리지 않고 fragment마다 검증하기 위해 **모든 fragment에 MAC을 붙여 전송한다**.

![Alt text](image-3.png)

## Format

![Alt text](image-4.png)

type, version, length는 암호화되지 않고, Data와 HMAC은 세션키에 의해 암호화된다. 

type은 TLS 메세지가 Handshake인지 Application Data인지 구분하는 데에 사용하고, TLS Connection을 종료할 때에도 사용한다. 

version은 TLS 프로토콜의 버전을 의미한다.

length는 암호화된 데이터의 길이를 의미한다.

# IPSec

TLS가 전송 계층에서 사용한 보안 프로토콜이라면, IPSec은 네트워크 계층에서 사용하는 보안 프로토콜이다.  

## Mode

IPSec에는 두 가지 모드가 있다.
- Transport Mode : payload만 암호화한다.
- Tunnel Mode : datagram 전체를 암호화한다. 암호환 datagram은 새로운 datagram으로 캡슐화한다.

## Protocol

- Authentication Header(AH) Protocol : 헤더만 암호화하기 때문에 무결성을 검증할 수 없다.
- Encapsulation Security Protocol (ESP) : 무결성, 인증, 기밀성을 제공해서 AH보다 더 많이 쓴다.

## Security Associations

암호화된 datagram을 전송하기 전에 두 노드간에 보안 환경이 구성되어 있어야 한다. 이를 Security Association이라고 한다. 두 노드는 서로 같은 보안 속성을 기억하고 있어야 한다. 

- Security Parameter Index : SA를 식별하기 위한 id로 사용
- Destination IP Address : 하나의 IP마다 유일한 SA를 사용
- Security Protocol Identifier : AH, ESP중 하나 사용
- Encryption Key
- Authentication Key
- 무결성, 및 인증 방식 등

## IPSec Datagram

![Alt text](image-5.png)

보낼 datagram 뒤에 Trailer를 붙인 후 SA에 정의된 방식으로 암호화한다. 그 다음 Header와 Auth 필드를 붙여 무결성 검증 처리를 한 뒤 새로운 IP Header를 붙여 전송한다.

ESP Header에는 replay attack을 막기 위해 Sequence Number가 들어있다. 

ESP Trailer에는 block cipher attack을 막기 위해 padding을 붙인다.

ESP Auth에는 SA에서 정의한 MAC이 들어간다.

이렇게 구성한 IPSec Datagram으로 상대방에게 전송한다.

### Sequence Number

새로 SA를 구성하면 0번부터 시작한다. replay 공격을 막기 위해서 매번 datagram을 송신할 때마다 값을 1씩 증가시킨다. 

## IP Security Databases

### Security Policy Databse (SPD)

> SPD: What to do

송신자는 이 datagram이 IPSec을 사용하는지 알아야 한다. 그리고 어떤 SA를 사용해야하는지 결정해야한다. 이에 대한 정보들이 이 DB에 저장된다.

### Security Association Database (SAD)

> SAD: How to do

Endpoint는 SAD안에 SA상태를 저장한다. 송신자가 IPsec datagram을 보낼 때 송신자와 연결된 라우터는 SAD에 접속하여 어떻게 datagram을 전송해야할지 결정한다.

수신자와 연결된 라우터는 SPI를 조사하고 SPI를 인덱싱하여 처리한다.

# Internet Key Exchange (IKE)

SA를 생성하기 위해 키 교환을 수행하여 보안 요소들을 설정한다.

## Pre Shared secret Key (PSK)

미리 공유된 키로 시작하여 인증을 진행하고 SA를 생성한다. 

## Public Key Infrastructure (PKI)

공개키/비밀키로 시작하여 인증을 진행하고 SA를 생성한다.

# 무선 및 모바일 네트워크 보안

TCP Connection 이후에 Handshake를 진행했던 것처럼, 무선 네트워크 또한 AP와 모바일 디바이스간 연결이 먼저 구성된 후에 Authentication Server와 모바일 디바이스간 인증을 진행한다. 

1. Discovery of security capabilities

    와이파이마다 인증을 거치지 않는 것과 인증을 요구하는(비밀번호를 사용하는) 것이 있다. 이에 대한 정보는 AP의 **Beacon frame**에서 얻는다. Beacon frame에는 인증 여부 및 암호화 알고리즘에 대한 정보가 포함되어 있고, 모바일 디바이스는 Beacon frame을 수신하여 그 정보를 획득하게 된다.

2. Mutual authentication and shared symmetric key derivation

    와이파이 비밀번호처럼 이미 알고 있는 공유키(대칭키), 그리고 모바일 디바이스가 생성한 난수 및 해시 함수(무결성 검증 용도)를 사용하여 인증을 시도한다. 

    결과적으로 AS와 모바일 디바이스간 handshake를 통해 세션키를 생성하게 된다.

3. Shared symmetric session key distribution

    세션키가 생성이 되었다면 AS는 AP에게 세션키를 전달하여 모바일 디바이스와 AP간 보안 환경을 구성한다.

## WPA3 handshake

![Alt text](image-6.png)

Authentication Server(AS)와 모바일 디바이스가 WPA3를 사용하여 인증할 때 거치는 과정이다. (위에서 2단계에 해당)

AP와 모바일 디바이스 사이에 이미 공유된 대칭키 $$K_{M-AP}$$(예를 들어 비밀번호)가 이미 존재한다고 가정한다.

1. AS는 난수 $$R_{AS}$$를 생성해서 모바일에게 전달한다. 
2. 모바일 디바이스는 서버가 보낸 난수 $$R_{AS}$$를 수신한 후, 모바일 디바이스의 난수 $$R_{M}$$를 생성한다. **AS의 난수** $$R_{AS}$$와 **모바일의 난수** $$R_{M}$$ 그리고 **둘 사이에 공유된 대칭키** $$K_{M-AP}$$를 통해 세션키를 생성한다. 

    모바일 디바이스는 AS에게 자신이 생성한 난수를 전송하되, 서버의 난수 $$R_{AS}$$와 공유된 대칭키 $$K_{M-AP}$$를 사용하여 HMAC으로 무결성 검증 보호를 거친 후 전송한다.

3. AS는 수신한 데이터의 무결성을 검증한 뒤 모바일 디바이스의 난수를 얻으므로 AS 또한 세션키를 생성하게 된다.

## Extensible Authentication Protocol (EAP)

네트워크와 인터넷 연결에 사용되는 인증 프레임워크다. 무선 네트워크와 AS간 인증의 표준이 된다.

# Authentication, Encryption in 4G

4G 환경 또한 모바일 디바이스와 Base Station이 먼저 물리적으로 연결되어야 보안 환경을 구성할 수 있다.

4G 환경에서는 모바일 디바이스가 SIM카드를 가진다. SIM카드 내부에는 공유된 키가 포함되어 있다. 모바일 디바이스는 자신이 가입한 네트워크에서 설정된 인증 방식을 통해 인증을 진행하게 된다. 즉, 가입자의 서비스에 따라 더 강력한 인증을 진행하게 된다.

[WPA3 handshake](#wpa3-handshake)에서 모바일 디바이스와 AS간 세션키를 생성했듯이 이번에도 같은 방법으로 모바일 디바이스와 Base Station은 세션키를 생성하여 보안 환경을 구성하게 된다. 대신, 방문자 네트워크와 홈 네트워크가 모두 AS로 동작하게 된다. 궁극적으로는 홈 네트워크의 AS가 상위 레벨로 동작한다. 

두 AS간 인증을 모두 진행해야하므로 모바일 디바이스는 미리 두 개의 키를 알고 있어야 한다. 하나는 BS간에 공유된 키이고 나머지는 HSS간에 공유된 키다.

![Alt text](image-7.png)

1. Authenticaion request to HSS

    모바일 디바이스는 attach 메세지를 HSS에게 전송한다. 이 메세지는 모바일 디바이스의 IMSI와 방문자 네트워크의 정보를 포함한다. 이 메세지는 BS, MME를 거쳐 HSS에게 전달된다.

2. HSS Generate auth_token, $$xres_{HSS}$$

    HSS는 모바일 디바이스와 미리 공유한 키$$K_{HSS-M}$$를 이용해 auth_token을 생성한다. auth_token에는 HSS가 $$K_{HSS-M}$$을 통해 암호화한 정보가 들어있다. 이 정보는 auth_token을 생성한 자가 미리 공유한 키에 대해서 알고 있음을 의미한다. 
    
    그리고 $$xres_{HSS}$$를 생성한다. 방문자 네트워크는 이 키를 기억하였다가 이후 인증 절차에 사용한다.

3. Authentication response from mobile

    모바일 디바이스 또한 $$K_{HSS-M}$$을 사용하여 $$res_M$$을 생성하는데, HSS가 $$xres_{HSS}$$를 생성할 때 사용한 암호화 알고리즘을 적용한다. 생성한 $$res_M$$를 방문자 네트워크로 전송한다.

4. Compare two keys, $$xres_{HSS}$$ with $$res_M$$

    방문자 네트워크는 모바일 디바이스가 전송한 $$res_M$$과 홈 네트워크가 전송한 $$xres_{HSS}$$를 비교한다. 두 토큰이 동일하면 모바일 디바이스에게 인증되었다고 알린다.

    이후에는 [WPA3 handshake](#wpa3-handshake)에서 진행했던 것처럼 모바일 디바이스와 방문자 네트워크간 보안 환경을 구성한다.

## Difference between 4G, 5G

4G에서는 방문자 네트워크 즉, MME가 인증을 담당했지만, 5G에서는 홈 네트워크가 그 역할을 맡게 된다.

4G는 미리 공유된 키를 통해 인증을 진행했지만 5G에서는 IoT를 위해 미리 공유된 키를 사용하지 않는다.

4G는 모바일 디바이스의 IMSI가 평문으로 전송되지만, 5G에서는 암호화되어 전송된다.

# 방화벽

- 무수한 요청으로 공격하는 방법을 막는다.
- 허용하지 않는 요청을 막는다.
- 인증된 노드만 접근하도록 한다.

## Stateless packet filter

![Alt text](image-8.png)

IP주소, 프로토콜, 포트, flag 등 다양한 조건으로 deny 또는 allow한다. 이 규칙이 정리된 테이블을 **Access Control Lists(ACL)**라고 한다.

## Stateful packet filter

![Alt text](image-9.png)

한 번 필터를 통과한 세션은 그대로 믿는 방법이다. 모든 패킷을 방화벽에 통과시켜서 방어하려면 많은 오버헤드가 필요하기 때문에 효율적으로 방화벽을 사용할 수 있다. 이 때 ACL에 각 세션을 등록하여 검사를 하지 않고 그냥 통과시킬지 업데이트한다.

## Application Gateway

Application data로 필터링한다. 모든 데이터를 특정 게이트웨이로 통과시킨 다음 데이터를 해독하여 검사한다. 이 방법은 오버헤드가 꽤 크다.

### Intrusion Detection System (IDS)

패킷 속 데이터를 분석하여 네트워크에 대한 공격인지 확인한다. 방화벽과 같이 작동할 수도 있고, 다른 노드 사이에서 작동할 수 있다.

# IDS