---
title: 디자인 패턴 용어 정리
description: GoF의 디자인 패턴이라는 책을 공부한 후 관련된 용어를 정리한 글입니다.
date: '2023-07-13T05:27:20.856Z'
tags: ["design-pattern"]
---

# 객체

데이터 + 프로시저(데이터를 다루는 연산, 작업)를 함께 묶은 단위다.

객체는 요청을 통해 내부에 있는 데이터 또는 상태를 변경한다.

요청은 **객체의 상태를 변경하는 유일한 방법**이다. 오직 요청을 통해서만 가능하도록 제약 사항을 거는데, 이걸 캡슐화라고 한다. 캡슐화를 통해 객체의 내부 동작을 숨겨 외부에서 알 수 없도록 한다.

실세계를 토대로 객체를 구성하다보면 현재의 모습만 반영한 모델이 될 뿐 미래의 요청 사항을 반영할 수 없는 모델이 된다. 디자인 패턴을 통해 유연한 설계를 거쳐 미래의 실세계를 잘 반영할 수 있도록 한다.

# 인터페이스

객체가 요청을 받아 처리할 수 있는 모든 연산들의 집합이다.

특정 인터페이스를 지칭하기 위해 타입을 이용해 나타낸다.

객체는 여러 인터페이스를 가질 수 있고, 인터페이스가 다른 인터페이스를 가질 수도 있다. 

이 때 다른 인터페이스를 가지는 인터페이스를 서브타입이라고 하고 다른 인터페이스에 포함되는 인터페이스를 슈퍼타입이라고 한다. 간단하게 나타내기 위해 인터페이스를 상속한다고 표현한다.

객체는 **오직 이 인터페이스를 통해 자신을 드러낸다**. 그러나 내부 구현은 객체에 정의된 내용에 따라 달라진다. 동일한 요청이라도 객체마다 다른 방식으로 동작한다. 

요청에 따라 실행될 연산을 *런타임 시점*에 결정짓게 되는데, 이것을 동적바인딩이라고 한다. 동일한 요청이지만 처리할 객체에 따라 다른 동작을 보여준다는 점은 객체지향의 특징인 다형성이 드러난다고 할 수 있다. 

# 인터페이스에 따르는 프로그래밍

추상 클래스를 정의하고 인터페이스로 사용하여 상속받을 경우 두 가지 이점이 있다.

- 객체가 인터페이스를 지원하는 한 객체의 구체적인 타입을 알 필요는 없다.
- 객체를 구현하는 클래스가 어떤 것인지 알 필요는 없고 **인터페이스를 정의한 추상 클래스**만 알면 된다.

이 내용은 의존성 역전 원칙과 비슷한 내용같다. 추상화에 의존하여 구현해야한다.

# 상속과 합성

상속은 부모 클래스의 구현을 그대로 받아와 하위 클래스의 구현을 정의하는 것이다.

*컴파일 시점*에 정적으로 정의되고 하위 클래스에서 부모 클래스에 정의된 구현을 재정의할 수 있다.

하지만 부모 클래스에 정의된 구현을 **런타임 시기에 변경할 수 없고**, 부모 클래스의 요구사항이 달라졌다거나 정의된 구현이 변경될 경우 종속된 하위 클래스에게도 영향이 가기 마련이다.

합성은 **객체가 다른 객체에 대한 참조자를 얻는 방식**이다. 객체 내에 구현된 프로시저보다 인터페이스에 정의된 내용만 바라보게 된다. 동일한 인터페이스라면 *런타임 시점*에 다른 객체로 대체될 수 있고, 인터페이스에 맞춰 객체를 구현하기 때문에 종속성도 줄어들게 된다.

일반적으로 상속보다 합성을 좋은 방법이라고 한다.

# 위임

수신 객체와 위임자가 한 요청을 처리하는 것이다. 수신 객체가 요청을 수신하고, 위임자에게 이 요청을 처리해달라고 한다. 

위임자는 런타임에 변경될 수 있으므로 요청을 처리하는 방법도 달라질 수 있다. 이를 위해서는 수신 객체가 위임자를 인스턴스로(**Has-A**관계로) 갖고 있어야 한다.
